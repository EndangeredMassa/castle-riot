Painting = require 'painting'
Direction = require 'player/directions'
Score = require 'score'
Map = require 'map'
Player = require 'player'
LightingComposition = require 'lighting_composition'
InstructionsView = require 'instructions-view'
DisconnectView = require 'disconnect-view'
MiniMap = require 'mini-map'

# TODO: Centralize the footprint adjustment

Game = module.exports = ->
  @opponents = {}
  @paintings = {}
  @currentDirection = ''
  @lastActive = new Date
  @timeoutDuration = 60 * 1000 # 60 seconds
  @isIdle = false

  socket = io.connect("//#{window.location.host}#{window.location.pathname}")


  updateScores = (scores) ->
    $('#guards-points').text scores.guards
    $('#thieves-points').text scores.thieves

    $list = $('#high-score-list')
    $list.html('')
    _.each scores.ordered, ({name, value, isGuard}) ->
      team = if isGuard then 'guards' else 'thieves'
      html = $('<tr><td class="first '+team+'">'+name+'</td><td>'+value+'</td></tr>')
      $list.append(html)

  socket.on 'init', (data) =>
    @map = new Map(data.map)

    player = data.player
    player.isMainPlayer = true
    player.x = player.x - 7
    player.y = player.y - 30
    @player = @createPlayer(player)

    @player.on "name-change", (name) =>
      socket.emit "player:name-change", name

    @player.on "stunned", ->
      $("#board").addClass "stunned"

    @map.centerOnSprite @player.sprite
    @instructionsView = new InstructionsView @player

    # scores
    new Score.View(@player.score)
    updateScores(data.scores)
    new MiniMap @player, @map

    opponents = data.opponents
    for __, opponent of opponents
      # hack to get init facing working
      opponent.currentDirection = opponent.faceDirection
      @opponents[opponent.id] = @createPlayer(opponent)

    for id, paintingData of data.paintings
      @addPainting(paintingData)

    @lightingComposition = new LightingComposition
      map: @map
      player: @player
      opponents: @opponents
      canvas: jaws.canvas
      context: jaws.context

  socket.on 'score:update', updateScores

  socket.on 'player:connected', (player) =>
    player.x = player.x - 7
    player.y = player.y - 30
    @opponents[player.id] = @createPlayer(player)

  socket.on 'player:disconnected', (player) =>
    @removePlayer(player)

  @createPlayer = (options) =>
    options.map = @map
    player = new Player(options)

    @map.addPlayer player
    player.destroy = =>
      @removePlayerFromServer(player)
      @removePlayer(player)

    if options.isMainPlayer
      player.score.on 'change', ->
        socket.emit 'score:update',
          id: player.id
          isGuard: player.isGuard
          name: player.name

    renderPlayerCounts()
    player

  @removePlayer = (player) =>
    @map.removePlayer(player.id)
    if player.id == @player?.id && !@isIdle
      delete @player
      @respawnPlayer()
    else if @isIdle
      new DisconnectView
    else
      delete @opponents[player.id]
    renderPlayerCounts()

  @removePlayerFromServer = (player) =>
    if player.isMainPlayer
      socket.emit 'player:remove', player.id

  @respawnPlayer = ->
    setTimeout ->
      window.location = window.location
    , 2000
    $("#container").fadeOut 2000

  @addPainting = (paintingData) ->
    painting = new Painting(paintingData)

    painting.on "pickedUp", (player) ->
      socket.emit "painting:pickedUp", painting.id, player.id
    painting.on "dropped", (player) ->
      socket.emit "painting:dropped", painting.id, player.id
    painting.on "moved", (coords) ->
      socket.emit "painting:moved", painting.id, x: coords.x, y: coords.y
    painting.on 'respawned', =>
      delete @paintings[painting.id]
      @map.removePainting(painting)
      socket.emit 'painting:removed', painting.id
    @paintings[painting.id] = painting
    @map.addPainting painting

    if p = @opponents[paintingData.playerId]
      getPainting = ->
        p.pickUpPainting painting
      setTimeout getPainting, 500

  renderPlayerCounts = =>
    guardCount = _.filter(@map.players, (p) -> p.isGuard).length
    thiefCount = _.filter(@map.players, (p) -> !p.isGuard).length
    $(".guards .number").text guardCount
    $(".thieves .number").text thiefCount

  socket.on 'player:update', (player) =>
    playerToUpdate = @opponents[player.id]

    return unless playerToUpdate
    playerToUpdate.orient(player.direction, { x: player.x, y: player.y })

  socket.on 'player:name-change', (playerId, name) =>
    if player = @opponents[playerId]
      player.updateName name

  socket.on 'painting:pickedUp', (paintingId, playerId) =>
    if (player = @opponents[playerId]) && (painting = @paintings[paintingId])
      player.pickUpPainting painting

  socket.on 'painting:dropped', (paintingId, playerId) =>
    if (player = @opponents[playerId]) && (painting = @paintings[paintingId])
      player.dropPainting painting

  socket.on 'painting:moved', (paintingId, coords) =>
    if painting = @paintings[paintingId]
      painting.move coords.x, coords.y

  socket.on 'painting:removed', (paintingId) =>
    if painting = @paintings[paintingId]
      @map.removePainting(painting)
      delete @paintings[paintingId]

  socket.on 'painting:spawned', (paintingData) =>
    @addPainting(paintingData)

  # Called once when a game state is activated. Use it for one-time setup code.
  @setup = ->
    if window.admin
      @fps = document.getElementById('fps')
      @fps.style.display = 'inline-block'
    jaws.preventDefaultKeys ['up', 'down', 'left', 'right', 'space']

  # update() will get called each game tick with your specified FPS. Put game logic here.
  @update = ->
    if @player
      direction = Direction.NONE
      if jaws.pressed 'up' && jaws.pressed 'down'
        direction = Direction.NONE
      else if jaws.pressed 'up'
        @player.moveUp()
        direction = Direction.N
      else if jaws.pressed 'down'
        @player.moveDown()
        direction = Direction.S

      if jaws.pressed 'left' && jaws.pressed 'right'
        direction += Direction.NONE
      else if jaws.pressed 'left'
        @player.moveLeft()
        direction += Direction.W
      else if jaws.pressed 'right'
        @player.moveRight()
        direction += Direction.E

      if direction != @currentDirection
        @lastActive = new Date
        @currentDirection = direction
        socket.emit 'player:update',
          x: @player.x
          y: @player.y
          direction: direction
      else if new Date - @lastActive > @timeoutDuration && !@isIdle && !window.admin
        @isIdle = true
        @player.destroy()

      if jaws.pressed 'd'
        @player.dropPainting()

      if jaws.pressed('esc') || jaws.pressed('enter')
        @instructionsView.close()

    for id, opponent of @opponents
      opponent.moveInCurrentDirection()

    @map.update() if @map

    @fps?.innerHTML = jaws.game_loop.fps + ' FPS'

  # Directly after each update draw() will be called. Put all your on-screen operations here.
  @draw = ->
    jaws.clear()
    @lightingComposition.draw() if @lightingComposition

  # NOTE: The loading breaks if you try to remove this
  undefined

Game.assets = ['img/dungeon.png', 'img/thief.png', 'img/guard.png', 'img/painting1.png', 'img/door.png']
